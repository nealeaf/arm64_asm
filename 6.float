在 AARCH64 架构中，浮点运算涉及四个主要概念：
独立的浮点寄存器集：除了整数寄存器外，还有专门用于浮点值的寄存器。
专门的浮点指令：有一组专门用于浮点值的指令。
SIMD 指令：可以对一组浮点值进行操作的特殊指令。
浮点与整数寄存器之间的转换指令：用于在浮点寄存器和整数寄存器之间移动数据的指令。
浮点寄存器
浮点寄存器有多种别名，具体取决于如何引用它们。常见的别名包括：
B0：8 位无符号整数
H0：16 位无符号整数
S0：32 位单精度浮点数
D0：64 位双精度浮点数
这些别名决定了寄存器中的数据如何被解释。例如，S0 和 D0 分别表示单精度和双精度浮点数。
浮点指令
专门的浮点指令
这些指令用于基本的浮点运算，如加法、减法、乘法和除法。例如：
fadd：浮点加法
fsub：浮点减法
fmul：浮点乘法
fdiv：浮点除法
转换指令
用于在不同精度之间转换浮点值，或将浮点值转换为整数，反之亦然。例如：
fcvt：在不同精度的浮点值之间转换
fcvtzs：将浮点值截断为有符号整数
fcvtzu：将浮点值截断为无符号整数
比较指令
用于比较两个浮点值。例如：
fcmp：浮点比较
SIMD 指令
SIMD（单指令多数据）指令允许对一组数据进行单个操作，从而提高性能。例如，NEON 指令集提供了对浮点数组进行并行操作的能力。
浮点与整数寄存器之间的转换
使用 fmov 指令可以在浮点寄存器和整数寄存器之间移动数据。需要注意的是，fmov 只是复制位，不进行数值转换。例如：
fmov x0, d0：将双精度浮点值从 d0 移动到整数寄存器 x0
fmov d0, x0：将整数值从 x0 移动到双精度浮点寄存器 d0
注意事项
不要混合不同精度的操作：即使浮点寄存器在内存占用上可能有重叠，混合不同精度的操作可能导致无意义的结果。
理解寄存器的别名：正确引用浮点寄存器的别名，以确保数据被正确解释。
示例代码
以下是一个简单的示例，展示如何在 AARCH64 汇编中使用浮点寄存器和指令：
        .text
        .global main
        .align  2

main:
        stp     x29, x30, [sp, -16]!    // 保存帧指针和返回地址
        mov     x29, sp                 // 设置当前帧指针

        // 加载浮点值
        ldr     d0, =1.5                // 加载双精度浮点值 1.5 到 d0
        ldr     s1, =1.5                // 加载单精度浮点值 1.5 到 s1

        // 浮点运算
        fadd    d2, d0, d0              // d2 = d0 + d0
        fmul    s2, s1, s1              // s2 = s1 * s1

        // 转换为整数
        fcvtzs  x3, d2                  // 将 d2 截断为有符号整数
        fcvtzu  w4, s2                  // 将 s2 截断为无符号整数

        // 恢复栈和返回
        ldp     x29, x30, [sp], 16
        ret
总结
浮点寄存器：有独立的寄存器集，通过别名（如 S0、D0）引用。
浮点指令：包括基本运算、转换和比较指令。
SIMD 指令：用于并行处理浮点数据。
转换指令：用于在浮点寄存器和整数寄存器之间移动数据。
注意事项：避免混合不同精度的操作，正确理解寄存器别名。
