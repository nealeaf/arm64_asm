fmov 指令在 AARCH64 架构中用于在浮点寄存器之间移动浮点值，以及在一定程度上在整数寄存器和浮点寄存器之间移动数据。然而，fmov 的使用有一些限制，尤其是在处理立即数（Immediate Values）时。以下是对 fmov 指令的详细解释：
1. 浮点立即数的限制
与整数寄存器类似，浮点寄存器也可以通过 fmov 指令直接加载立即数，但并不是所有浮点值都可以作为立即数使用。这取决于立即数的编码方式以及指令的大小限制。
示例代码及解释
  fmov    d0, 1.0         // 可以正常工作
  fmov    d0, 1.5         // 可以正常工作，相当于 2**-1
  fmov    d0, 1.75        // 可以正常工作，相当于 2**-1 + 2**-2
  fmov    d0, 1.875       // 可以正常工作，相当于 2**-1 + 2**-2 + 2**-3
  fmov    d0, 1.9375      // 可以正常工作，相当于 2**-1 + 2**-2 + 2**-3 + 2**-4
  fmov    d0, 1.96875     // 无法正常工作
从这些例子中可以看出：
尾数（Mantissa）的限制：fmov 指令的立即数部分只有 4 位 可用于尾数。因此，只有那些分数部分由以下组合构成的浮点值可以作为立即数使用：1/2 1/4 1/8 1/16
指数（Exponent）的限制：fmov 可以处理 3 位 的指数，因此可以使用 ±2^7范围内的指数。
符号位（Sign Bit）：还有一个符号位用于表示正负，因此总共可以使用的位数为 8 位。
2. 加载和存储浮点数的一般方法
当不确定是否可以直接使用 fmov 加载浮点立即数时，建议从内存中加载固定的浮点数。这种方法更为通用且不会受到立即数限制的影响。
示例代码
ldr     d0, =1.96875    // 从内存加载浮点数
3. SIMD 操作中的 fmov
fmov 指令还可以处理由 SIMD（单指令多数据）指令引起的复杂特殊情况。它可以将值在不同宽度的寄存器之间移动，例如从单精度寄存器移动到双精度寄存器。然而，fmov 不会执行任何数值转换，它只是简单地复制位。
示例代码
fmov    s0, d0          // 将双精度值复制到单精度寄存器（不转换）
如果需要改变浮点值的精度，必须使用 fcvt 指令族（例如 fcvtss、fcvtsd 等）。
4. 在整数寄存器和浮点寄存器之间移动数据
fmov 可以在整数寄存器和浮点寄存器之间复制位。需要注意的是，fmov 不会执行任何数值转换，它只是简单地复制位。如果需要进行数值转换（例如将整数转换为浮点数或反之），需要使用其他指令。
示例代码
fmov    x0, d0          // 将浮点寄存器的值复制到整数寄存器（不转换）
fmov    d0, x0          // 将整数寄存器的值复制到浮点寄存器（不转换）
总结
浮点立即数限制：fmov 的立即数部分只有 4 位用于尾数，3 位用于指数，1 位用于符号。只有特定的浮点值可以作为立即数使用。
加载和存储浮点数：建议从内存加载浮点数以避免立即数限制。
SIMD 操作：fmov 可以在不同宽度的寄存器之间移动值，但不会执行数值转换。
整数和浮点寄存器之间的移动：fmov 可以在整数寄存器和浮点寄存器之间复制位，但不会执行数值转换
