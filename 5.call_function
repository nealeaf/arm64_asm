C语言代码
  void SillyFunction(long p1, long p2, long p3, long p4, 
                     long p5, long p6, long p7, long p8, 
                     long p9) {
      printf("This example hurts: %ld %ld\n", p8, p9);
  }
  
  int main() {
      SillyFunction(1, 2, 3, 4, 5, 6, 7, 8, 9);
  }
这段代码定义了一个函数 SillyFunction，它有9个参数。函数内部通过 printf 打印了第8个和第9个参数的值。
在 main 函数中，调用 SillyFunction 时传递了9个参数。
汇编代码分析
  SillyFunction:
          stp        x29, x30, [sp, -16]!    // 调整栈指针，保存帧指针和返回地址
          mov        x29, sp                  // 设置当前函数的帧指针
          ldr        x0, =fmt                 // 将格式字符串的地址加载到寄存器x0
          mov        x1, x7                   // 将第8个参数（在寄存器x7中）移动到寄存器x1
          ldr        x2, [sp, 16]            // 从栈中加载第9个参数到寄存器x2
          bl         printf                   // 调用printf函数
          ldp        x29, x30, [sp], 16      // 恢复帧指针和返回地址
          ret                                 // 返回到调用者
  
  main:
          stp        x29, x30, [sp, -16]!    // 调整栈指针，保存帧指针和返回地址
          mov        x29, sp                  // 设置当前函数的帧指针
          mov        x0, 9                    // 将第9个参数（9）放入寄存器x0
          str        x0, [sp, -16]!          // 将第9个参数存储到栈上
          mov        x0, 1                    // 将第1个参数（1）放入寄存器x0
          mov        x1, 2                    // 将第2个参数（2）放入寄存器x1
          mov        x2, 3                    // 将第3个参数（3）放入寄存器x2
          mov        x3, 4                    // 将第4个参数（4）放入寄存器x3
          mov        x4, 5                    // 将第5个参数（5）放入寄存器x4
          mov        x5, 6                    // 将第6个参数（6）放入寄存器x5
          mov        x6, 7                    // 将第7个参数（7）放入寄存器x6
          mov        x7, 8                    // 将第8个参数（8）放入寄存器x7
          bl         SillyFunction            // 调用SillyFunction
          add        sp, sp, 16               // 恢复栈指针
          ldp        x29, x30, [sp], 16      // 恢复帧指针和返回地址
          ret                                 // 返回到调用者
main 函数：
首先通过 stp 指令调整栈指针，为函数调用保存帧指针和返回地址。
将第9个参数（9）存储到栈上，因为寄存器已经用于前8个参数。
将前8个参数分别放入寄存器 x0 到 x7。
调用 SillyFunction。
调用完成后，恢复栈指针和帧指针。
SillyFunction 函数：
同样保存帧指针和返回地址。
将格式字符串的地址加载到寄存器 x0。
将第8个参数（在寄存器 x7 中）移动到寄存器 x1，作为 printf 的第二个参数。
从栈中加载第9个参数到寄存器 x2，作为 printf 的第三个参数。
调用 printf 打印结果。
恢复帧指针和返回地址，然后返回。
栈状态变化分析
在 main 函数中执行 stp x29, x30, [sp, -16]! 后，栈的状态如下：
sp + 0：main 的返回地址
sp + 8：旧的帧指针内容
执行 str x0, [sp, -16]! 后，栈的状态如下：
sp + 0：第9个参数（9）
sp + 8：垃圾值（未定义）
sp + 16：main 的返回地址
sp + 24：旧的帧指针内容
在 SillyFunction 中执行 stp x29, x30, [sp, -16]! 后，栈的状态如下：
sp + 0：SillyFunction 的返回地址
sp + 8：垃圾值
sp + 16：第9个参数（9）
sp + 24：垃圾值
sp + 32：main 的返回地址
sp + 40：旧的帧指针内容
ldr x2, [sp, 16] 指令从栈中加载第9个参数（9）到寄存器 x2，作为 printf 的第三个参数。
函数参数传递规则
通过寄存器和栈传递参数：
在许多调用约定中（包括Linux系统中使用的ARM架构），函数的前8个参数通过寄存器传递（x0 到 x7）。如果函数有超过8个参数，从第9个参数开始，参数会通过栈传递。
例如，在示例代码中，SillyFunction 函数有9个参数。前8个参数通过寄存器传递，而第9个参数（p9）通过栈传递。
栈的调整规则：
在ARM架构中，栈指针（sp）的调整必须是16字节的倍数。这是因为ARM架构要求栈保持16字节对齐。
例如，如果需要在栈上分配1个字节的空间，栈指针必须向下调整16字节；如果需要分配17字节的空间，栈指针必须向下调整32字节，以此类推。
